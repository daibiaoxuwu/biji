#### 编译原理LR文法

##### 种类

LR（0）分析
SLR（1）分析: simple...
LR（1）分析
LALR（1）分析: lookahead...

##### 转移表

action表: 含有s1, r1等和acc. sx代表进栈一个符号并转移到状态x;

r代表弹出"一个产生式"个符号并按GOTO表转移状态.

##### LR(0)分析

先要增广. S'->S.

活前缀: 从开头到不超过下一个句柄的"前缀".

LR(0)只要一直读到一个完整的句柄, 规约掉, 继续读就行了. 每个时刻栈里都是活前缀.

产生式加原点: 项目.

A->α.B(第一个大写字母)β 加入B->.γ 只加**第一个大写字母**

初始S'->.S 按上述规则扩展出FSM的第一个状态I0. (叫做{S'->.S}的 **闭包** CLOSURE)

I0的点不断右移产生其他状态.直到右移到每个项目的结尾. I0吃一个X后下一个状态是"吃了X后的那些规则"的 **闭包**.

根据吃的符号是终结符还是非终结符, 放到ACTION还是GOTO表里.

状态机接受的是所有活前缀.

如果闭包里有A->xxxx. 那么整行ACTION都写成rj. GOTO不影响. 这个j不对应状态, 而是对应第几个产生式.

可能的冲突: SR和RR. S'->S.不是规约而是(唯一的)"接受"项目, 不算冲突.

简单地说, 对LR(0), 如果一个状态里有A->xxxx., 那么它不能往外指箭头. 这个可以避免SR冲突. 同时, 一个状态里不能有不同的A->xxxx. 有RR冲突.

##### SLR(1)

SR冲突中, 可以通过看一个字符, 通过Follow集合解决: 如果Follow集合和"往外指的箭头"不重叠, 那么当符号是Follow集合里的时候规约, 是"往外指的箭头"时往外走.解决SR冲突. (因为规约只能是Follow集合的. SR冲突举例: if x 和if x else y).

RR冲突中, 那些R的Follow集合如果不冲突, 也可以符合SLR(1)文法.

与LR(0)不同的地方在于, SLR(1)中规约不再是"一行全r", 而是对Follow集合内的写r.

对于某些错误报告来说，LR（0）分析会比 SLR（1） 分析晚一些.



