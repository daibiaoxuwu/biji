#### 编译原理1012-1019

##### 词法分析和语法分析

* 词法分析: 提取每个单词

  * 分类为"标识符" "乘号"等, 并给出属性("标识符"的名字)等. 

  * 在PA1A的lexer.l文件中, 生成每个词的semvalue, 供后面byacc语法分析的$$.expr, $2.ident什么的调用.

    ```java
    "||"				{ return operator(Parser.OR);			}
    "|||"				{ return operator(Parser.GUARDOR);			}
    {SIMPLE_OPERATOR}	{ return operator((int)yycharat(0));	}
    ```

  * 扩展巴克斯范式（EBNF） 

  * ```java
    <无符号整数>  ::=  <数字> {<数字>}
    <标识符>          ::=  <字母> {<字母> | <数字>} 
    ```

    生成自动机并简化, 然后运行.

* 语法分析: 构建语法树

  * byacc的工作, 就是在parser.y里写的那些正则式子

    ``` java
    ClassList       :	ClassList ClassDef
    					{
    						$$.clist.add($2.cdef);
    					}
                    |	ClassDef
                    	{
                    		$$.clist = new ArrayList<Tree.ClassDef>();
                    		$$.clist.add($1.cdef);
                    	}
                    ;
    ```

  * 分为自顶向下语法分析和自底向上语法分析

* 自顶向下语法分析

  * 和byacc一样, 从一个根节点用**上下文无关文法(而不是正则文法)**分析程序.

  * 非确定性: 下一步应该走哪个式子

    * 替换哪个_非终结符_: 这个问题被"只替换最左边"解决, 因为(定理)最左推导存在且唯一
    * 用哪个产生式

  * LL(K)文法: 决定用哪个产生式, 只要看几个字符即可不再回溯. (最小K=1)

       回溯会带来大量的性能浪费.

  * LL: 第一个L是"从左向右扫描"; 第二个是"产生最左推导"

  * 举例: 如果文法含左递归, 则不可能是LL(K)文法.

  * 计算first集合: 
     * first集合的定义:

       ![1539674998556](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539674998556.png)

       直译: 对任意一个"**各种符号** 的串", 它的first集合为"这个串能推出的所有 **各种符号** 的串(第一个字是非终结符)的第一个字符.
       简译: 也就是它最后能推出的东西的第一个字符, 用于预测.

       自顶向下的规约方法, 已知终结符串, 求规约树: "下一个第一个字符"已经知道了, 用first可以大致预测下一个用哪个式子的几种可能性.

     * 算法: 计算: 单个的**任意符号**, e, 和所有规约式右侧的所有后缀(后缀: 含自己)

       ![1539307274795](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539307274795.png)

       对"非终结符", "终结符", "产生式右边的串" 以及它们的所有后缀计算.

         1. 初始化: 对单个终结符和e, first集合置为自己;

     ​		对非终结符:first置为空.

     ​		然后, 重复2,3,4直到不变.

     2. 对任何一个规约式A->e, 其first集合并上e;
     3. 对任何一个"规约式右侧的所有后缀"v:
        * 如果v的任何一个字符都有规约式到e Y->e, 整个式子v的first集合等于每个字符first集合的并
        * 如果v的前 i-1 个字符都能规约式到e Y->e, 第i个不能,则整个式子的first集合等于前i个字符的first集合的并, 去掉e.
     4. 任何一个非终结符的first集合, 要并上其所有产生式右侧**完整**式子的first集合.

    * 计算follow集合

        * 定义: **只对非终结符有效**

          ![1539680547932](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539680547932.png)

          意思是: 算了一半的时候, 这个非终结符后面的全部串的First集合之并.

          #是加的.类似正则的$符, 而不是"最后一个字符".LL(1)补一个就好.LL(K)要补充K个.

          S"后面的全部串"只有#号.所以follow(S)={#}, 不再变化. (S属于非终结符)

        * 算法:

          ![1539681044697](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539681044697.png)

          意思: S=>a'Ab', (a,b是串而不是字符), A->aBb

          那么相当于S=>a'aBbb'

          A的Follow集合为b'的所有式子, 如果b推出空的, 那么B的follow就是所有b'的first集合之并.也就是A的follow集合.

  * 预测集合:

       * 定义:

            ![1539908550131](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539908550131.png)

       * 预测集合是只含终结符, 不含e的. 

       * 可用于判断:

            ![1539908636888](C:\Users\d\AppData\Roaming\Typora\typora-user-images\1539908636888.png)

       * 验证是不是LL(1):

         看那些有多个产生式的. 它们的产生式PS集合之间有没有交集.

       * ...

       * 简单恢复处理

       * 短语层面的恢复处理

         如果分析到S的时候, 遇到的符号不是S开始符号:

         一直跳过符号,直到遇到:

         * S的开始符号: 重新分析S

           开始符号就是S的first集合

         * S的结束符号: 假装S已经分析完了, 继续

           结束符号指的是: 如果A->aBb, B的结束符号是**B外边的**下一个符号, 即为b的first集合.

           可能比B的follow集合小, 因为已经知道A是什么了.

         如果分析完S的时候, 遇到的符号不是S结束的符号:

         一直跳过符号, 直到遇到(和上面相同):

         * S的开始符号: 重新分析S
         * S的结束符号: 假装S已经分析完了, 继续

       * 消除左递归

         许多文法在消除左递归和提取左公因子后可以变换为LL(1)文法.

         但不含左递归和左公因子的文法不一定都是 LL(1)文法.